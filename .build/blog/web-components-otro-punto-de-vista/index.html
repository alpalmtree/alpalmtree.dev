<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Components: Miedo y Asco en la Web | El jard√≠n de Al</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçÇ</text></svg>" />
    <meta name="description" content="Causantes de decepci√≥n en algunas personas e ilusi√≥n de un mundo sin React en otras. ¬øY si cambiamos la perspectiva un poquito?">
    
            <link rel="stylesheet" href="/resources/css/pages/common.css?rel=1751957454717">
        
    
            <link rel="stylesheet" href="/resources/css/pages/post.css?rel=1751957454717">
        

    
            <script type="module" src="/resources/js/pages/common.js?rel=1751957454717"></script>
        
</head>

<body><header class="container lg">
    <nav>
        <ul role="list">
            <li>
                <view-link>
                    <a href="/" class="logo" aria-label="Enlace a la p√°gina de inicio">üçÇ</a>
                </view-link>
            </li>
        </ul>
        <ul role="list">
            <li>
                <view-link>
                    <a href="/explora/">Explora</a>
                </view-link>
            </li>
            <li>
                <view-link>
                    <a href="/el-menda/">El menda</a>
                </view-link>
            </li>
            <li><x-toggle>
  <label>
    <!-- From Uiverse.io by JkHuger -->
    <input class="toggle-checkbox" type="checkbox" name="dark-light" aria-label="Cambia entre el modo claro y oscuro"/>
    <div class="toggle-slot">
      <div class="sun-icon-wrapper">
        <div
          class="iconify sun-icon"
          data-icon="feather-sun"
          data-inline="false"
        >
        </div>
      </div>
      <div class="toggle-button"></div>
      <div class="moon-icon-wrapper">
        <div
          class="iconify moon-icon"
          data-icon="feather-moon"
          data-inline="false"
        >
        </div>
      </div>
    </div>
  </label>
</x-toggle>
            </li>
        </ul>
    </nav>
</header>
    <view-partial script="/resources/js/pages/post.js?rel=1751957454718">
        <main>
            <article class="flow">
                <h1>Web Components: Miedo y Asco en la Web</h1>
                <p class="lede">Causantes de decepci√≥n en algunas personas e ilusi√≥n de un mundo sin React en otras. ¬øY si cambiamos la perspectiva un poquito?</p>
                <p class="pub-date">
                    <strong>14/6/25 | √Ålvaro Palma</strong>
                </p>
<img 
    srcset="/resources/images/blog/web-components-otro-punto-de-vista/img_md.webp 700w, /resources/images/blog/web-components-otro-punto-de-vista/img_sm.webp 411w"
    sizes="(min-width: 1000px) 700px, 100%"
    alt="Imagen en blanco y negro con dithering de una pieza de lego insertada en medio de una placa."
    width="750"
    height="562">
                <p>Sinceramente, creo que lejos queda la virtud del t√©rmino medio. Mientras que algunas personas piensan <a href="https://dev.to/ryansolid/web-components-are-not-the-future-48bh">que el coste de los Web Components</a> no justifica su caso de uso, otras opinan que &quot;se acab√≥ usar React&quot;.</p>
<p>Bueno, de hecho s√≠ que existe un t√©rmino medio (no te f√≠es de todo lo que diga un extra√±o en internet). Hace alg√∫n tiempo me top√© con <a href="https://nolanlawson.com/2023/08/23/use-web-components-for-what-theyre-good-at/">este art√≠culo</a> al respecto; y creo que la argumentaci√≥n est√° bastante bien expuesta. Existen otros al respecto donde se alaba el uso de los Web Components &quot;para lo que de verdad son √∫tiles&quot;.</p>
<p>Y sin embargo, ya sea a favor o en contra, casi toda la literatura que podemos encontrar en este respecto comente siempre el mismo error: comparar los Web Components con una librer√≠a / framework (de aqu√≠ en adelante, diremos simplemente <em>React</em>). Opino que es un error porque olvidan la idiosincrasia de los Web Components. A fin de cuentas, son una tecnolog√≠a (de hecho, <strong>un conjunto de tecnolog√≠as</strong>) nativas de la plataforma web. Como tal, existen tantos casos de uso como programadoras hay en el mundo. La lista de casos que podemos enumerar como respuesta a la pregunta de &quot;<em>¬øPara qu√© me sirven los Web Components?</em>&quot; crece con cada caso en el que t√∫ le encuentres alguna utilidad.</p>
<p>Si esta es la primera vez que oyes hablar de los Web Components, te recomiendo que primero busques alg√∫n tutorial y entonces vuelvas por aqu√≠. Cualquiera nos vale. Hay <strong>una barbaridad</strong> de art√≠culos y v√≠deos sobre los Web Components. Te apuesto lo que quieras (menos dinero) a que tu <em>influencer</em> de referencia tiene algo al respecto.</p>
<h2>Los tres pilares: El Shadow DOM, el elemento <code>template</code> y los Custom Elements</h2>
<p>El t√©rmino &quot;Web Components&quot; es realmente el nombre que se le da a estas tres tecnolog√≠as que podemos encontrar en cualquier navegador moderno. Normalmente, la tecnolog√≠a m√°s llamativa es la de los Custom Elements; y, por ende, es lo que m√°s se usa para hablar y para poner ejemplos de uso de los Web Components.</p>
<p>Vamos a repasarlas una por una, con casos de uso aislados los unos de los otros y en el contexto de Vanilla JavaScript.</p>
<h3>Shadow DOM</h3>
<p>En t√©rminos generales, el Shadow DOM nos permite crear un &quot;DOM&quot; encapsulado dentro de cualquier elemento HTML que pueda contener nodos anidados. √âchale un ojo al art√≠culo en <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM">MDN</a>.</p>
<p>Normalmente, se suele usar mucho con los Custom Elements porque, mientras que los primeros ayudan a servir de <em>namespace</em> para m√©todos y propiedades, el Shadow DOM nos proporciona una encapsulaci√≥n similar a la que podr√≠amos ver en algunos frameworks.</p>
<p>Veamos (muy por encima) un ejemplo:</p>
<code-hl group="shadow-dom" name="app.js" open>

<pre><code class="language-js">const appRoot = document.getElementById(&quot;app-root&quot;);

appRoot.attachShadow({ mode: &quot;open&quot; });
const paragraph = document.createElement(&quot;p&quot;);
paragraph.textContent = &quot;Inside shadow DOM&quot;;

appRoot.shadowRoot.appendChild(paragraph);
</code></pre>
</code-hl>

<code-hl group="shadow-dom" name="app.html">

<pre><code class="language-html">&lt;p&gt;Outside shadow DOM&lt;/p&gt;
&lt;div id=&quot;app-root&quot;&gt;&lt;/div&gt;
</code></pre>
</code-hl>

<p>Veremos lo siguiente en el inspector del navegador:</p>
<code-hl>

<pre><code class="language-html">&lt;p&gt;Outside shadow DOM&lt;/p&gt;
&lt;div id=&quot;app-root&quot;&gt;
  #shadow-root (open)
    &lt;p&gt;Inside shadow DOM&lt;/p&gt;
&lt;/div&gt;
</code></pre>
</code-hl>

<p>Como podr√°s imaginar, cosas como las siguientes no afectan al p√°rrafo que se encuentra dentro del Shadow DOM:</p>
<code-hl>

<pre><code class="language-html">&lt;style&gt;
  p {
    color: red;
  }
&lt;/style&gt;
&lt;script type=&quot;module&quot;&gt;
  document
    .querySelectorAll(&quot;p&quot;)
    .forEach(
      (p) =&gt; (p.textContent = &quot;Modified from JS&quot;)
    );
&lt;/script&gt;
</code></pre>
</code-hl>

<p>As√≠ que, si en alg√∫n momento te encuentras con la necesidad de tener un trozo de HTML al que no le afecten estilos ni scripts generales de la p√°gina, el Shadow DOM es tu herramienta.</p>
<p>No obstante, tiene tambi√©n sus cosillas medio raras, especialmente en lo relacionado con la accesibilidad; y muchas veces la encapsulaci√≥n de estilos es algo que no es deseable para una aplicaci√≥n entera.</p>
<p>En definitiva, considero que es una herramienta muy √∫til; pero puedes evitarla totalmente. Nadie va a meterse contigo porque uses Web Components y no uses el Shadow DOM (y si lo hacen, no son tus amigos).</p>
<h3>El elemento <code>template</code></h3>
<p>Si sabes de qu√© va el tema de crear elementos HTML complejos con JavaScript, sabr√°s que puede llegar a ser algo tedioso. Por esto mismo tenemos el elemento <code>template</code>.</p>
<p>La manera m√°s sencilla, sin <code>template</code>s, ser√≠a probablemente haciendo uso de la propiedad <code>innerHTML</code>. Pero sabemos que no solo es ineficiente, sino que tambi√©n puede llegar a ser problem√°tico para casos de XSS. En general, ninguna parte de tu HTML que pueda estar controlada por alg√∫n tipo de input que no controles. Si a√∫n s√≠ quieres hacerlo con <code>innerHTML</code>, tienes que asegurarte de que esas partes din√°micas est√°s correctamente sanitizadas; y a√∫n hay partes que se te podr√≠an escapar. Un rollo, vamos.</p>
<p>Aqu√≠ es donde entra el elemento <code>template</code>. Los <code>template</code>s pueden existir en el DOM que haya renderizado tu servidor, de modo que puedes usarlos para compartir informaci√≥n front-back. Sin embargo, no es hasta que t√∫ expl√≠citamente decides hacer algo con ellos que realmente se hacen visibles, de modo que tienes tambi√©n la oportunidad de inyectar contenido din√°mico de forma segura.</p>
<code-hl group="template" name="app.js" open>

<pre><code class="language-js">const appRoot = document.getElementById(&quot;app-root&quot;);
const form = document.getElementById(&quot;hi-form&quot;);
const messageTemplate = document.getElementById(&quot;message-template&quot;);

form.addEventListener(&quot;submit&quot;, (e) =&gt; {
  e.preventDefault();
  const name = new FormData(e.target).get(&quot;name&quot;);
  e.target.reset();

  const message = messageTemplate.content.cloneNode(true);
  message.querySelector(&quot;strong&quot;).textContent = name;

  appRoot.querySelector(&quot;p&quot;)?.replaceWith(message);
});

const initialMessage = messageTemplate.content.cloneNode(true);
initialMessage.querySelector(&quot;strong&quot;).textContent = &quot;stranger&quot;;
appRoot.appendChild(initialMessage);
</code></pre>
</code-hl>

<code-hl group="template" name="app.html">

<pre><code class="language-html">&lt;div id=&quot;app-root&quot;&gt;
    &lt;form action=&quot;#&quot; id=&quot;hi-form&quot;&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;Tell us your name&quot; name=&quot;name&quot; /&gt;
        &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;template id=&quot;message-template&quot;&gt;
    &lt;p&gt;Hello, &lt;strong&gt;&lt;/strong&gt;! Welcome to my app!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
</code-hl>

<p>Crear elementos HTML con <code>document.createElement</code> y manipular sus atributos y propiedades de forma imperativa es ligeramente m√°s r√°pido, pero creo que las ventajas de hacerlo a trav√©s de <code>template</code>s son evidentes. Es mucho m√°s ergon√≥mico que crearlos de forma program√°tica y mucho m√°s eficiente y seguro que usar <code>innerHTML</code> (adem√°s de, como mencion√© anteriormente, poder renderizar en el servidor un trozo de HTML que luego puedes usar en el lado del cliente).</p>
<h4>El elemento <code>template</code> y el Shadow DOM</h4>
<p>Si hasta ahora estas dos tecnolog√≠as te han parecido √∫tiles, tengo buenas noticias: forman un d√∫o <strong>muy</strong> bueno. Combi√°ndolas y haciendo uso del elemento <code>slot</code>, podemos conseguir elementos mixtos de <em>light</em> y <em>shadow</em> DOM con composiciones relativamente complejas. Un ejemplo muy tonto pero que creo que ilustra muy bien las posibilidades. N√≥tese c√≥mo no estamos escribiendo ni una sola l√≠nea de JavaScript para que funcione:</p>
<code-hl group="template-shadow" name="app.html" open>

<pre><code class="language-html">&lt;div id=&quot;app-root&quot;&gt;
    &lt;p&gt;
      I belong to the light DOM and I&#39;ll be placed between two red paragraphs
    &lt;/p&gt;

    &lt;template shadowrootmode=&quot;open&quot;&gt;
      &lt;style&gt;
        p {
          color: red;
        }
      &lt;/style&gt;

      &lt;p&gt;I belong to the shadow DOM and hence I&#39;m red&lt;/p&gt;
      &lt;slot&gt;&lt;/slot&gt;
      &lt;p&gt;I also belong to the shadow DOM&lt;/p&gt;
    &lt;/template&gt;
&lt;/div&gt;
</code></pre>
</code-hl>

<code-hl group="template-shadow" name="app.js">

<pre><code class="language-js">const appRoot = document.getElementById(&quot;app-root&quot;).shadowRoot;

// Length: 2
const shadowParagraphs = appRoot.querySelectorAll(&quot;p&quot;);
// Length: 1
const lightDOMParagraphs = document.querySelectorAll(&quot;p&quot;);
</code></pre>
</code-hl>

<p>Como ya mencion√© anteriormente, el Shadow DOM tiene sus cosillas; y peor incluso si empezamos a mezclarlo tambi√©n con el <em>light</em> DOM. Pero bueno, es cuesti√≥n de aprender a usarlos con cabeza. Personalmente, me fascina c√≥mo podemos conseguir elementos h√≠bridos donde tenemos una parte renderizada en el cliente (aunque de facto exista ya en el HTML del documento), con l√≥gica y estilos encapsulados; y otra parte que sigue el flujo normal que esperas de tu DOM, con los estilos y l√≥gica globales.</p>
<h3>Custom Elements</h3>
<p>Llegados a este punto, espero que ya te hayas familiarizado algo m√°s con las otras dos tecnolog√≠as; y que hayas apreciado c√≥mo se pueden utilizar de forma totalmente independiente. Junto con los <em>Custom Elements</em>, encontramos una tr√≠ada de herramientas que nos pueden hacer la vida mucho m√°s f√°cil en nuestras aplicaciones escritas en <strong>Vanilla JavaScript</strong>.</p>
<p>El matiz es importante. Recordemos que los Web Components son, en su conjunto, unas herramientas que podemos encontrar integradas en la plataforma web, no muy diferente de un <code>querySelector</code> o de un <code>MutationObserver</code>. Dada su idiosincrasia, los problemas que ayudan a resolver pueden estar ya cubiertos por alg√∫n framework o librer√≠a. Por ejemplo, temas como la encapsulaci√≥n, la creaci√≥n de plantillas de forma declarativa para usarlas a trav√©s de JavaScript o, como veremos, la organizaci√≥n de propiedades y m√©todos: Si ya est√°s usando alg√∫n framework como Angular, React o Vue, ya cuentas con mecanismos que resuelven todo esto, adem√°s de ofrecerte reactividad y otras cosillas tope guapas con mucha magia detr√°s.</p>
<p>Para hablar de los Custom Elements, me gustar√≠a alejarme del discurso tradicional de los cientos de tutoriales que hay por internet; y centrarme en lo que opino que son incre√≠bles aisl√°ndolos de las otras dos herramientas:</p>
<h4>Hidratar tu HTML de forma declarativa</h4>
<p>Creo que la &quot;confusi√≥n&quot; (o simplemente, el uso de la comunidad) de los t√©rminos &quot;Web Components&quot; y &quot;Custom Elements&quot; nos han dado la clave bajo un concepto muy interesante: <em>HTML Web Components</em>.</p>
<p>En resumidas cuentas, este modelo de Web Components hace principalmente uso de los Custom Elements en un contexto en el que su contenido no necesita ser renderizado con JavaScript, sino que ya se encuentra en el DOM. Es una manera de asegurarte una mejora progresiva de tus aplicaciones sin necesidad de usar constantemente <code>querySelector</code>s. Para ejemplificarlo, vamos a complicar un poco m√°s uno de los ejemplos anteriores:</p>
<code-hl group="custom-elements" name="app.html" open>

<pre><code class="language-html">&lt;body&gt;
  &lt;header&gt;
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;Some static content&lt;/li&gt;
        &lt;li&gt;
          &lt;input
            id=&quot;toggle-schema&quot;
            type=&quot;checkbox&quot;
            aria-label=&quot;toggle dark and light mode&quot;
          /&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  &lt;/header&gt;
  &lt;div id=&quot;app-root&quot;&gt;
    &lt;form action=&quot;#&quot; id=&quot;hi-form&quot;&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Tell us your name&quot; name=&quot;name&quot; /&gt;
      &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;template id=&quot;message-template&quot;&gt;
    &lt;p&gt;Hello, &lt;strong&gt;&lt;/strong&gt;! Welcome to my app!&lt;/p&gt;
  &lt;/template&gt;
&lt;/body&gt;
</code></pre>
</code-hl>

<code-hl group="custom-elements" name="app.js">

<pre><code class="language-js">const toggleSchema = document.getElementById(&quot;toggle-schema&quot;);
const appRoot = document.getElementById(&quot;app-root&quot;);
const form = document.getElementById(&quot;hi-form&quot;);
const messageTemplate = document.getElementById(&quot;message-template&quot;);

const doToggle = (toggle) =&gt; {
  document.body.dataset.theme = toggle.checked ? &quot;dark&quot; : &quot;light&quot;;
};

const createMessage = (text) =&gt; {
  const message = messageTemplate.content.cloneNode(true);
  message.querySelector(&quot;strong&quot;).textContent = text;
  appRoot.querySelector(&quot;p&quot;)?.replaceWith(message) ??
    appRoot.appendChild(message);
};

toggleSchema.addEventListener(&quot;change&quot;, ({ target }) =&gt; {
  doToggle(target);
});

form.addEventListener(&quot;submit&quot;, (e) =&gt; {
  e.preventDefault();
  const name = new FormData(e.target).get(&quot;name&quot;);
  e.target.reset();

  createMessage(name);
});

doToggle(toggleSchema);
createMessage(&quot;stranger&quot;);
</code></pre>
</code-hl>

<p>Aqu√≠ est√°n pasando varias cosillas:</p>
<ol>
<li>Aunque tengamos regiones de hidrataci√≥n claramente diferenciadas, estamos buscando en el DOM completo. En una aplicaci√≥n m√°s compleja, posiblemente merecer√≠a la pena seleccionar primero estas regiones (por ejemplo, <code>nav</code>, <code>div#app-root</code>...) y luego ya buscar los elementos que queramos hidratar dentro de estas regiones.</li>
<li>Tanto en este ejemplo como si queremos seleccionar primero las regiones individuales, estamos inicializ√°ndolo todo manualmente y de forma imperativa...</li>
<li>... de modo que si alg√∫n elemento no estuviera presente en el DOM en el momento de la ejecuci√≥n del script, nos lo saltamos por completo. Tenemos que tener en cuenta cualquier mutaci√≥n que se haga del DOM. Quiz√°s para mutaciones controladas por nosotras mismas no es para tanto (aunque s√≠ un poco tedioso), pero imag√≠nate que estamos mandando HTML <em>over the wire</em>, con librer√≠as como <a href="https://turbo.hotwired.dev/">Turbo</a> o <a href="https://htmx.org/">HTMX</a>.</li>
<li><em>Grosso modo</em>, estamos declarando variables y m√©todos en el <em>scope</em> global y estamos ejecutando las √≥rdenes paso a paso de forma imperativa. Esto se puede mitigar mediante la toma de decisiones de arquitectura; pero, ¬øy si te digo que los Custom Elements pueden ayudarnos precisamente con esto?</li>
</ol>
<p>Veamos el ejemplo usando <em>HTML Web Components</em> (o, como a m√≠ me gusta llamarlos, simplemente <em>Custom Elements</em>):</p>
<code-hl group="custom-elements-2" name="app.html" open>

<pre><code class="language-html">&lt;body&gt;
  &lt;header&gt;
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;Some static content&lt;/li&gt;
        &lt;li&gt;
          &lt;toggle-element&gt;
            &lt;input
              id=&quot;toggle-schema&quot;
              type=&quot;checkbox&quot;
              aria-label=&quot;toggle dark and light mode&quot;
            /&gt;
          &lt;/toggle-element&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  &lt;/header&gt;
  &lt;app-root&gt;
    &lt;form action=&quot;#&quot;&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Tell us your name&quot; name=&quot;name&quot; /&gt;
      &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;
    &lt;/form&gt;
    &lt;template id=&quot;message-template&quot;&gt;
      &lt;p&gt;Hello, &lt;strong&gt;&lt;/strong&gt;! Welcome to my app!&lt;/p&gt;
    &lt;/template&gt;
  &lt;/app-root&gt;
&lt;/body&gt;
</code></pre>
</code-hl>

<code-hl group="custom-elements-2" name="app.js">

<pre><code class="language-js">customElements.define(
  &quot;toggle-element&quot;,
  class extends HTMLElement {
    toggle = this.querySelector(&quot;input[type=checkbox]&quot;);
    doToggle = () =&gt; {
      document.body.dataset.theme = this.toggle.checked ? &quot;dark&quot; : &quot;light&quot;;
    };

    connectedCallback() {
      this.doToggle();
      this.addEventListener(&quot;change&quot;, this.doToggle);
    }
  }
);

customElements.define(
  &quot;app-root&quot;,
  class extends HTMLElement {
    form = this.querySelector(&quot;form&quot;);
    messageTemplate = this.querySelector(&quot;template&quot;);

    createMessage = (text) =&gt; {
      const message = this.messageTemplate.content.cloneNode(true);
      message.querySelector(&quot;strong&quot;).textContent = text;
      this.querySelector(&quot;p&quot;)?.replaceWith(message) ??
        this.appendChild(message);
    };

    connectedCallback() {
      this.createMessage(&quot;stranger&quot;);
      this.form.addEventListener(&quot;submit&quot;, (e) =&gt; {
        e.preventDefault();
        const name = new FormData(e.target).get(&quot;name&quot;);
        e.target.reset();

        this.createMessage(name);
      });
    }
  }
);
</code></pre>
</code-hl>

<p>Veamos qu√© est√° pasando aqu√≠ y por qu√© est√° tan jodidamente guapo en comparaci√≥n con el ejemplo anterior:</p>
<ol>
<li>Las regiones de hidrataci√≥n est√°n claramente marcadas por sus respectivos Custom Elements, por lo que podemos hacer las b√∫squedas directamente dentro de estas regiones de forma declarativa, sin necesidad de andar seleccion√°ndolas primero.</li>
<li>Los Custom Elements ya nos dan esa organizaci√≥n de la que habl√°bamos antes. Cada m√©todo y propiedad relacionados con la manipulaci√≥n del DOM est√°n contenidos dentro de una clase, de modo que no estamos contaminando el <em>scope</em> global.</li>
<li>En relaci√≥n con el primer punto, dado que ya estamos seleccionando los elementos dentro de un <em>scope</em> muy espec√≠fico, podemos usar selectores mucho menos complejos.</li>
<li>Son <strong>Elementos HTML reales</strong>. Hacer un <code>document.querySelector(&quot;toggle-element&quot;).doToggle()</code> es igual de v√°lido y nos dar√° el mismo resultado que acceder a cualquier m√©todo o propiedad nativos de un elemento HTML espec√≠fico. Esto simplifica el modelo mental de c√≥mo compartir estado en el DOM sin necesidad de recurrir al cl√°sico <em>prop drilling</em> o a librer√≠as de gesti√≥n de estado.</li>
<li>F√≠jate en el m√©todo <code>connectedCallback</code>. Este m√©todo se invoca autom√°ticamente cuando el navegador detecta que el elemento est√° presente en el DOM. Tenemos tambi√©n la contraparte <code>disconnectedCallback</code>, que hace lo que su propio nombre indica. Esto significa que tenemos <em>lifecycle methods</em> sin necesidad de andar usando un <code>MutationObserver</code> o de ejecutar las acciones respectivas de forma imperativa.</li>
<li>En l√≠neas generales, cuando el navegador detecta que hemos creado un Custom Element (ya sea a trav√©s de <code>document.createElement</code> o bien directamente en el HTML de tu servidor), se encarga autom√°ticamente de crear la instancia respectiva y de llamar a los m√©todos correspondientes. Me gusta compararlo con CSS. Imag√≠nate que tuvieras que declarar los estilos cada vez que manipulas el DOM. Pues lo mismo, pero para JavaScript.</li>
</ol>
<h2>Resumiendo, que es gerundio</h2>
<p>Espero haber dejado clara mi postura: no es justo comparar los Web Components con un framework. Los Web Components son un conjunto de herramientas nativas de la plataforma web y, como tal, tienen sus cosas raras y decepcionantes tambi√©n que otros frameworks como <a href="https://lit.dev/">Lit</a> est√°n intentando solventar. Igual que pas√≥ con jQuery y el <code>querySelector</code> en el pasado.</p>
<p>Lo que s√≠ creo que es un puntazo sobre los Web Components es que ayudan a mitigar los quebraderos de cabeza que nos podemos encontrar en nuestras aplicaciones hechas con vanilla JavaScript. A fin de cuentas, son el resultado de d√©cadas de avance en la plataforma web.</p>
<p>Puedes usar las tres herramientas, solo un par, o usarlas solo en una peque√±a parte de tu aplicaci√≥n. Lo m√°s bonito que tienen los Web Components es que no van a ser una dependencia m√°s en tu proyecto que prometiste a tu jefe que ibas a actualizar hace ya un a√±o. Son parte de la plataforma web, y por tanto son &quot;gratis&quot;. Puedes usarlos solamente hasta el punto en el que te sientas c√≥moda y no m√°s all√°.</p>
<p>Los Web Components han venido para quedarse. Van mejorando poco a poco; y tan solo pueden seguir mejorando. Qui√©n sabe si en un futuro veremos alg√∫n mecanismo de reactividad, alguna manera m√°s ergon√≥mica de atacar la componetizaci√≥n y el renderizado en el cliente, mejoras en accesibilidad y rendimiento, compatibilidad entre navegadores...</p>
<p>Qui√©n sabe qu√© nos deparan los avances de la plataforma web. Quiz√°s entonces; y solo entonces, podamos compararlo con React o cualquier otro framework. Hasta entonces, tan solo podemos compararlos con los miles de mecanismos que ya encontramos en la plataforma web.</p>

            </article>
        </main>
    </view-partial><footer>
    <div class="container">
        <hr />
        <p>
            <small>
                C√≥digo y contenido generado por m√≠ mismo o copiado y debidamente acreditado de otro ser humano. Ninguna IA ha tenido nada que ver con todo esto.
                <br>
                Que le jodan a la IA. Que le jodan al capitalismo.
            </small>
        </p>
        <nav>
            <ul role="list">
                <li>
                    <small>¬© √Ålvaro Palma, 2025</small>
                </li>
            </ul>
            <ul role="list">
                <li>
                    <a href="https://github.com/alpalmtree" target="_blank" aria-label="github profile">
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                            stroke-width="2">
                            <path stroke-dasharray="32" stroke-dashoffset="32"
                                d="M12 4c1.67 0 2.61 0.4 3 0.5c0.53 -0.43 1.94 -1.5 3.5 -1.5c0.34 1 0.29 2.22 0 3c0.75 1 1 2 1 3.5c0 2.19 -0.48 3.58 -1.5 4.5c-1.02 0.92 -2.11 1.37 -3.5 1.5c0.65 0.54 0.5 1.87 0.5 2.5c0 0.73 0 3 0 3M12 4c-1.67 0 -2.61 0.4 -3 0.5c-0.53 -0.43 -1.94 -1.5 -3.5 -1.5c-0.34 1 -0.29 2.22 0 3c-0.75 1 -1 2 -1 3.5c0 2.19 0.48 3.58 1.5 4.5c1.02 0.92 2.11 1.37 3.5 1.5c-0.65 0.54 -0.5 1.87 -0.5 2.5c0 0.73 0 3 0 3">
                                <animate fill="freeze" attributeName="stroke-dashoffset" dur="1.05s" values="32;0" />
                            </path>
                            <path stroke-dasharray="10" stroke-dashoffset="10"
                                d="M9 19c-1.41 0 -2.84 -0.56 -3.69 -1.19c-0.84 -0.63 -1.09 -1.66 -2.31 -2.31">
                                <animate fill="freeze" attributeName="stroke-dashoffset" begin="1.2s" dur="0.3s"
                                    values="10;0" />
                            </path>
                        </g>
                    </svg>
                    </a>
                </li>
                <li>
                    <a href="https://bsky.app/profile/alpalmtree.dev" target="_blank" aria-label="bluesky profile">
                       <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-dasharray="80" stroke-dashoffset="80" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7.47 5.94c1.83 1.37 3.81 4.14 4.53 5.63c0.72 -1.49 2.7 -4.26 4.53 -5.63c1.33 -0.99 3.47 -1.75 3.47 0.68c0 0.49 -0.28 4.08 -0.45 4.66c-0.57 2.03 -2.65 2.55 -4.5 2.23c3.24 0.55 4.06 2.36 2.28 4.17c-3.38 3.44 -4.85 -0.87 -5.23 -1.97c-0.07 -0.2 -0.1 -0.3 -0.1 -0.22c-0 -0.08 -0.03 0.02 -0.1 0.22c-0.38 1.1 -1.86 5.41 -5.23 1.97c-1.78 -1.81 -0.96 -3.63 2.28 -4.17c-1.85 0.31 -3.93 -0.21 -4.5 -2.23c-0.17 -0.58 -0.45 -4.18 -0.45 -4.66c0 -2.43 2.14 -1.67 3.47 -0.68Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.9s" values="80;0"/></path></svg>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</footer>
</body>

</html>